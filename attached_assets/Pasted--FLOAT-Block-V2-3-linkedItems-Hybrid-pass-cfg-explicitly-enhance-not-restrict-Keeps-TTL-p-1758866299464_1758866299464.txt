// FLOAT Block V2.3 â€” linkedItems Hybrid (pass cfg explicitly, enhance not restrict)
// Keeps: TTL per note/heading, [[Note/Heading]] extraction, depth=0 preserved,
//        debug shadows, Obsidian/HTML blocks, model by NAME, in-draft overrides.

/* ====================== CONFIG PERSISTENCE ====================== */

const CONFIG_PATH = "/Library/Scripts/float_block_v2_config.json";
const fm = FileManager.createCloud();

function getDefaults() {
  const known = AnthropicAI.knownModels() || [];
  let defaultModel = known[0] || "claude-3-haiku-20240307";
  for (const m of known) { if ((m || "").toLowerCase().includes("haiku")) { defaultModel = m; break; } }
  return {
    depth: 1,                 // 0 = no expansion
    expandHistory: false,
    promptEachRun: false,
    model: defaultModel,      // store NAME directly
    maxTokens: 2048,
    debugMode: false,
    useObsidianSyntax: true,
    useLinkedItemsIndex: true // prefer Draft.linkedItems when available
  };
}

function loadConfig() {
  const defaults = getDefaults();
  if (!fm.exists(CONFIG_PATH)) return defaults;

  try {
    const saved = JSON.parse(fm.readString(CONFIG_PATH));
    const cfg = { ...defaults };

    if (Number.isInteger(saved.depth) && saved.depth >= 0) cfg.depth = saved.depth;
    cfg.expandHistory = !!saved.expandHistory;
    cfg.promptEachRun = !!saved.promptEachRun;
    cfg.debugMode = !!saved.debugMode;
    cfg.useObsidianSyntax = saved.useObsidianSyntax !== false;
    cfg.useLinkedItemsIndex = saved.useLinkedItemsIndex !== false;

    // Legacy support (modelIndex) OR current (model by name)
    if (typeof saved.model === "string" && saved.model.trim()) {
      cfg.model = saved.model.trim();
    } else if (Number.isInteger(saved.modelIndex)) {
      const known = AnthropicAI.knownModels() || [];
      cfg.model = known[saved.modelIndex] || defaults.model;
    }

    // ðŸ”§ Patch 2: normalize numeric-like strings to model name
    const knownForNormalize = AnthropicAI.knownModels() || [];
    if (typeof cfg.model === "string" && /^\d+$/.test(cfg.model)) {
      const idx = parseInt(cfg.model, 10);
      if (knownForNormalize[idx]) cfg.model = knownForNormalize[idx];
    }

    const mt = parseInt(saved.maxTokens, 10);
    cfg.maxTokens = Number.isFinite(mt) && mt > 0 ? mt : defaults.maxTokens;

    return cfg;
  } catch (e) {
    console.log("Config read error:", e);
    return defaults;
  }
}

function saveConfig(cfg) {
  const out = {
    depth: (Number.isInteger(cfg.depth) && cfg.depth >= 0) ? cfg.depth : 1, // preserve 0
    expandHistory: !!cfg.expandHistory,
    promptEachRun: !!cfg.promptEachRun,
    model: (typeof cfg.model === "string" && cfg.model.trim()) ? cfg.model.trim() : getDefaults().model,
    maxTokens: (Number.isFinite(parseInt(cfg.maxTokens, 10)) && parseInt(cfg.maxTokens, 10) > 0) ? parseInt(cfg.maxTokens, 10) : 2048,
    debugMode: !!cfg.debugMode,
    useObsidianSyntax: cfg.useObsidianSyntax !== false,
    useLinkedItemsIndex: cfg.useLinkedItemsIndex !== false
  };
  fm.writeString(CONFIG_PATH, JSON.stringify(out));
  return out;
}

function promptForConfig(current) {
  const known = AnthropicAI.knownModels() || [];
  const modelChoices = known.length ? known : ["claude-3-haiku-20240307"];
  const preModel = (current.model && modelChoices.includes(current.model)) ? current.model : modelChoices[0];

  const p = new Prompt();
  p.title = "FLOAT Block V2.3 â€¢ Configuration";

  p.addPicker("depth", "Wikilink Expansion Depth",
    [Array.from({ length: 7 }, (_, i) => String(i))],
    [String(current.depth)]
  );
  p.addSwitch("expandHistory", "Expand wikilinks in history", current.expandHistory);
  p.addPicker("model", "Model", [modelChoices], [preModel]); // returns VALUE (guard below)
  p.addTextField("maxTokens", "Max tokens", String(current.maxTokens));
  p.addSwitch("debugMode", "Enable debug shadow drafts", current.debugMode);
  p.addSwitch("useObsidianSyntax", "Use Obsidian %% %% syntax", current.useObsidianSyntax !== false);
  p.addSwitch("useLinkedItemsIndex", "Prefer Draft.linkedItems index", current.useLinkedItemsIndex !== false);
  p.addSwitch("promptEachRun", "Prompt each run", current.promptEachRun);

  p.addButton("Save & Run");
  p.addButton("Cancel");
  if (!p.show()) { context.cancel(); return null; }

  const depthVal = parseInt(p.fieldValues.depth[0], 10);

  // Selected model value (Drafts sometimes returns index; guard for numeric)
  let selectedModelVal = (p.fieldValues.model && p.fieldValues.model[0]) ? String(p.fieldValues.model[0]) : modelChoices[0];
  if (/^\d+$/.test(selectedModelVal)) {
    const idx = parseInt(selectedModelVal, 10);
    if (modelChoices[idx]) selectedModelVal = modelChoices[idx];
  }

  const cfg = {
    depth: Number.isInteger(depthVal) && depthVal >= 0 ? depthVal : current.depth,
    expandHistory: !!p.fieldValues.expandHistory,
    promptEachRun: !!p.fieldValues.promptEachRun,
    model: selectedModelVal, // store NAME directly
    maxTokens: parseInt(p.fieldValues.maxTokens, 10) || current.maxTokens,
    debugMode: !!p.fieldValues.debugMode,
    useObsidianSyntax: !!p.fieldValues.useObsidianSyntax,
    useLinkedItemsIndex: !!p.fieldValues.useLinkedItemsIndex
  };
  return saveConfig(cfg);
}

/* ====================== INLINE CONFIG IN DRAFT ====================== */

function parseConfigFromDraft(content) {
  const config = {};
  const lines = content.split('\n');

  for (const line of lines) {
    const depthMatch = line.match(/^-?\s*depth::(\d+)/i);
    if (depthMatch) config.depth = parseInt(depthMatch[1], 10);

    const expandMatch = line.match(/^-?\s*expandHistory::(true|false|yes|no|on|off)/i);
    if (expandMatch) {
      const v = expandMatch[1].toLowerCase();
      config.expandHistory = (v === "true" || v === "yes" || v === "on");
    }

    const debugMatch = line.match(/^-?\s*debugMode::(true|false|yes|no|on|off)/i);
    if (debugMatch) {
      const v = debugMatch[1].toLowerCase();
      config.debugMode = (v === "true" || v === "yes" || v === "on");
    }

    const maxTokensMatch = line.match(/^-?\s*maxTokens::(\d+)/i);
    if (maxTokensMatch) config.maxTokens = parseInt(maxTokensMatch[1], 10);

    const modelMatch = line.match(/^-?\s*model::(.+)$/i);
    if (modelMatch) {
      let m = modelMatch[1].trim();
      // ðŸ”§ Patch 2 also for inline config: normalize numeric-like "model" to name
      const known = AnthropicAI.knownModels() || [];
      if (/^\d+$/.test(m)) {
        const idx = parseInt(m, 10);
        if (known[idx]) m = known[idx];
      }
      config.model = m;
    }

    const liMatch = line.match(/^-?\s*useLinkedItemsIndex::(true|false|yes|no|on|off)/i);
    if (liMatch) {
      const v = liMatch[1].toLowerCase();
      config.useLinkedItemsIndex = (v === "true" || v === "yes" || v === "on");
    }
  }
  return config;
}

function injectConfigIntoDraft(config) {
  const content = editor.getText();
  if (content.match(/^-?\s*(depth|expandHistory|debugMode|maxTokens|model|useLinkedItemsIndex)::/m)) return;

  const block = [
    ``,
    `%% Config - edit these to change settings %%`,
    `- depth::${config.depth}`,
    `- expandHistory::${config.expandHistory}`,
    `- debugMode::${config.debugMode}`,
    `- maxTokens::${config.maxTokens}`,
    `- model::${config.model}`,
    `- useLinkedItemsIndex::${config.useLinkedItemsIndex}`,
    `%% End Config %%`,
    ``,
    `---`,
    ``
  ].join('\n');

  const lines = content.split('\n');
  let insertIndex = 0;
  if (lines.length > 0 && lines[0].trim()) {
    insertIndex = 1;
    while (insertIndex < lines.length) {
      const t = lines[insertIndex].trim();
      if (t.startsWith('- ctx::') || t.startsWith('ctx::') || !t) insertIndex++;
      else break;
    }
  }
  lines.splice(insertIndex, 0, block);
  editor.setText(lines.join('\n'));
}

/* ====================== TTL SYSTEM (note + heading) ====================== */

class TTLManager {
  constructor() {
    this.noteTTL = new Map();                 // Map<noteLower, expiresAtTurn>
    this.headingTTL = new Map();              // Map<noteLower, Map<headLower, expiresAtTurn>>
    this.noteSkips = new Set();               // Set<noteLower>
    this.headingSkips = new Map();            // Map<noteLower, Set<headLower>>
  }
  parseTTLDirective(line) {
    const m = line.match(/^[\s-]*skip::(\d*)\s*\[\[([^\]]+)\]\]/);
    if (!m) return null;
    const turnsStr = m[1];
    const raw = m[2].trim();
    const { title, heading } = resolveNoteAndHeading(raw);
    if (!title) return null;
    if (turnsStr === '' || turnsStr === '0') {
      return { note: title, heading: heading || null, ttl: 0, type: 'permanent' };
    }
    const turns = parseInt(turnsStr, 10);
    if (!Number.isFinite(turns) || turns < 0) return null;
    return { note: title, heading: heading || null, ttl: turns, type: 'temporal' };
  }
  updateTTL(noteTitle, heading, ttl, currentTurn) {
    const noteKey = noteTitle.toLowerCase();
    const headKey = heading ? heading.toLowerCase() : null;
    if (ttl === 0) {
      if (headKey) {
        if (!this.headingSkips.has(noteKey)) this.headingSkips.set(noteKey, new Set());
        this.headingSkips.get(noteKey).add(headKey);
      } else {
        this.noteSkips.add(noteKey);
      }
      return;
    }
    const expiresAt = currentTurn + ttl;
    if (headKey) {
      if (!this.headingTTL.has(noteKey)) this.headingTTL.set(noteKey, new Map());
      this.headingTTL.get(noteKey).set(headKey, expiresAt);
    } else {
      this.noteTTL.set(noteKey, expiresAt);
    }
  }
  shouldInclude(noteTitle, heading, currentTurn) {
    const noteKey = noteTitle.toLowerCase();
    const headKey = heading ? heading.toLowerCase() : null;

    if (this.noteSkips.has(noteKey)) return false;
    if (headKey && this.headingSkips.get(noteKey)?.has(headKey)) return false;

    const noteExpire = this.noteTTL.get(noteKey);
    if (typeof noteExpire === 'number' && currentTurn > noteExpire) return false;

    if (headKey) {
      const hExpire = this.headingTTL.get(noteKey)?.get(headKey);
      if (typeof hExpire === 'number' && currentTurn > hExpire) return false;
    }
    return true;
  }
  getStatus(noteTitle, heading, currentTurn) {
    const noteKey = noteTitle.toLowerCase();
    const headKey = heading ? heading.toLowerCase() : null;

    if (this.noteSkips.has(noteKey)) return { status: 'skipped-note', remaining: 0 };
    if (headKey && this.headingSkips.get(noteKey)?.has(headKey)) return { status: 'skipped-heading', remaining: 0 };

    const noteExpire = this.noteTTL.get(noteKey);
    if (typeof noteExpire === 'number')
      return { status: 'ttl-note', remaining: Math.max(0, noteExpire - currentTurn), expiresAt: noteExpire };

    if (headKey) {
      const hExpire = this.headingTTL.get(noteKey)?.get(headKey);
      if (typeof hExpire === 'number')
        return { status: 'ttl-heading', remaining: Math.max(0, hExpire - currentTurn), expiresAt: hExpire };
    }
    return { status: 'unmanaged' };
  }
}

/* ====================== UTILS ====================== */

function fmtCtx(ts = new Date()) {
  const y = ts.getFullYear();
  const m = String(ts.getMonth() + 1).padStart(2, "0");
  const d = String(ts.getDate()).padStart(2, "0");
  const min = String(ts.getMinutes(), 10).padStart(2, "0");
  const h24 = ts.getHours();
  const ampm = h24 >= 12 ? "PM" : "AM";
  const h12 = String(((h24 + 11) % 12) + 1).padStart(2, "0");
  return `${y}-${m}-${d} @ ${h12}:${min}${ampm}`;
}
function trimTrailing(s) { return (s || "").replace(/\s+$/g, ""); }

function countTurns(content) {
  const m = content.match(/^##\s*(\d+)\s*-/gm);
  return m ? Math.max(...m.map(x => parseInt(x.match(/\d+/)[0], 10))) : 0;
}
function extractUserName(content) {
  const m = content.match(/^##\s*\d+\s*-\s*([^:]+):/m);
  if (m && m[1].toLowerCase() !== 'assistant') return m[1].trim();
  return 'evan';
}

/* ====================== BLOCK PARSING ====================== */

function parseBlocks(content, config) {
  const messages = [];
  let systemOverride = null;

  const patterns = [
    /<!--\s*block\s+(\w+)\s*-->([\s\S]*?)<!--\s*endblock\s*-->/g
  ];
  if (config.useObsidianSyntax) {
    patterns.push(/%%\s*block\s+(\w+)\s*%%([\s\S]*?)%%\s*endblock\s*%%/g);
  }

  const allBlocks = [];
  for (const re of patterns) {
    re.lastIndex = 0;
    let m;
    while ((m = re.exec(content)) !== null) {
      allBlocks.push({ role: (m[1] || "").toLowerCase(), content: (m[2] || "").trim(), start: m.index, end: m.index + m[0].length });
    }
  }
  allBlocks.sort((a, b) => a.start - b.start);

  let lastIndex = 0;
  for (const b of allBlocks) {
    if (lastIndex < b.start) {
      const before = cleanUserText(content.slice(lastIndex, b.start));
      if (before) messages.push({ role: 'user', content: before });
    }
    if (b.role === 'system') systemOverride = b.content;
    else if (b.role === 'assistant' || b.role === 'user') messages.push({ role: b.role, content: b.content });
    lastIndex = b.end;
  }
  if (lastIndex < content.length) {
    const after = cleanUserText(content.slice(lastIndex));
    if (after) messages.push({ role: 'user', content: after });
  }
  if (!messages.length) {
    const all = cleanUserText(content);
    if (all) messages.push({ role: 'user', content: all });
  }
  return { messages, systemOverride };
}

function cleanUserText(text) {
  const out = [];
  for (const line of (text || "").split('\n')) {
    const t = line.trim();
    if (!t) continue;
    if (/^##\s*\d+\s*-\s*[\w\s]+:?\s*$/.test(t)) continue; // "## N - name:"
    if (/^-?\s*ctx::/i.test(t)) continue;                  // ctx metadata
    out.push(line);
  }
  return out.join('\n').trim();
}

/* ====================== LINK RESOLUTION (linkedItems-aware) ====================== */

function resolveNoteAndHeading(linkText) {
  const raw = (linkText || "").trim();
  if (!raw) return { title: null, draft: null, heading: null };
  const slashIdx = raw.indexOf("/");
  if (slashIdx === -1) {
    const d = Draft.queryByTitle(raw)[0];
    return { title: raw, draft: d || null, heading: null };
  }
  const noteTitle = raw.slice(0, slashIdx).trim();
  const heading = raw.slice(slashIdx + 1).trim();
  const d = Draft.queryByTitle(noteTitle)[0];
  return { title: noteTitle, draft: d || null, heading: heading || null };
}

// Extract a single section by markdown heading (case-insensitive)
function extractSectionByHeading(d, headingRaw) {
  const body = d?.content || "";
  const heading = (headingRaw || "").trim();
  if (!heading) return null;

  const lines = body.split("\n");
  let found = false, level = null, buf = [];

  for (let i = 0; i < lines.length; i++) {
    const t = lines[i].trim();
    const m = t.match(/^(#{1,6})\s+(.*)$/);
    if (m) {
      const curLevel = m[1].length;
      const curTitle = m[2].trim();
      if (!found) {
        if (curTitle.toLowerCase() === heading.toLowerCase()) {
          found = true; level = curLevel; buf.push(lines[i]); // include the heading line
        }
      } else {
        if (curLevel <= level) break;
        buf.push(lines[i]);
      }
    } else if (found) {
      buf.push(lines[i]);
    }
  }
  return found ? buf.join("\n") : null;
}

// Build fast lookup from current draftâ€™s outgoing index
function buildOutgoingIndexFromLinkedItems(curDraft) {
  try {
    const items = curDraft.linkedItems || []; // array of LinkedItem
    const out = new Map(); // titleLower -> Set<headingsLower or null>
    for (const it of items) {
      if (!it || (it.type && String(it.type).toLowerCase() !== 'draft')) continue;
      const t = (it.title || '').trim();
      if (!t) continue;
      const tl = t.toLowerCase();
      if (!out.has(tl)) out.set(tl, new Set());
      const sect = (it.section || '').trim();
      if (sect) out.get(tl).add(sect.toLowerCase());
      else out.get(tl).add(null);
    }
    return out;
  } catch (e) {
    return new Map();
  }
}

// Hybrid extraction: parse [[...]] from message, then enhance via linkedItems (never restrict)
function extractOutgoingRequestsFromMessage(text, cfg, curDraft) {
  const requests = []; // { title, heading|null, draft }
  const idx = cfg.useLinkedItemsIndex ? buildOutgoingIndexFromLinkedItems(curDraft) : new Map();

  const matches = (text || "").match(/\[\[([^\]]+)\]\]/g);
  if (!matches) return requests;

  for (const raw of matches) {
    const inside = raw.slice(2, -2).trim();
    const { title, draft: d, heading } = resolveNoteAndHeading(inside);
    if (!title) continue;

    // Self-link protection
    if (d && d.uuid === curDraft.uuid) continue;

    // Enhance: if index knows this title, normalize heading case if present
    let finalHeading = heading || null;
    if (idx.size > 0) {
      const set = idx.get(title.toLowerCase());
      if (set && finalHeading) {
        const lower = finalHeading.toLowerCase();
        for (const h of set) {
          if (h && h.toLowerCase() === lower) { finalHeading = h; break; }
        }
      }
    }

    requests.push({
      title,
      heading: finalHeading,
      draft: d || Draft.queryByTitle(title)[0] || null
    });
  }
  return requests;
}

/* ====================== EXPANSION (TTL + headings + linkedItems) ====================== */

function expandWikilinks(text, ttlManager, currentTurn, cfg, depth = 1, visitedNotes = null) {
  if (depth <= 0) return text;
  if (!visitedNotes) visitedNotes = new Set();

  const lines = (text || "").split('\n');

  // Phase 1: TTL directives
  const ttlDirectives = [];
  for (const line of lines) {
    const ttl = ttlManager.parseTTLDirective(line);
    if (ttl) ttlDirectives.push(ttl);
  }

  // Phase 2: explicit links (hybrid)
  const linkRequests = extractOutgoingRequestsFromMessage(text, cfg, draft);

  // Phase 3: apply TTL updates; include temporal TTLs immediately
  const expansions = [];
  for (const dtt of ttlDirectives) {
    ttlManager.updateTTL(dtt.note, dtt.heading, dtt.ttl, currentTurn);
    if (dtt.type === 'temporal' && dtt.ttl > 0) {
      const tgt = Draft.queryByTitle(dtt.note)[0];
      if (tgt && tgt.uuid !== draft.uuid && !visitedNotes.has(dtt.note)) {
        visitedNotes.add(dtt.note);
        let expanded = tgt.content;
        if (depth > 1) expanded = expandWikilinks(expanded, ttlManager, currentTurn, cfg, depth - 1, visitedNotes);
        const label = dtt.heading ? `${dtt.note} / ${dtt.heading}` : dtt.note;
        expansions.push(`\n--- Context: ${label} (TTL: ${dtt.ttl} turns) ---\n${expanded}\n--- End: ${label} ---`);
      }
    }
  }

  // Phase 4: group explicit requests by note (sections > whole)
  const byNote = new Map(); // note -> { draft, headings:Set<string>, wantWhole:boolean }
  for (const req of linkRequests) {
    if (!req.draft) continue;
    if (req.draft.uuid === draft.uuid) continue;
    if (!ttlManager.shouldInclude(req.title, req.heading, currentTurn)) continue;

    let g = byNote.get(req.title);
    if (!g) { g = { draft: req.draft, headings: new Set(), wantWhole: false }; byNote.set(req.title, g); }
    if (req.heading) g.headings.add(req.heading);
    else g.wantWhole = true;
  }

  // Phase 5: render grouped expansions
  for (const [title, g] of byNote) {
    if (g.headings.size > 0) {
      visitedNotes.add(title);
      for (const h of g.headings) {
        let sect = extractSectionByHeading(g.draft, h);
        if (sect == null) sect = `_Section '${h}' not found in ${title}_`;
        if (depth > 1) sect = expandWikilinks(sect, ttlManager, currentTurn, cfg, depth - 1, visitedNotes);
        expansions.push(`\n--- Context: ${title} / ${h} ---\n${sect}\n--- End: ${title} / ${h} ---`);
      }
    } else if (g.wantWhole && !visitedNotes.has(title)) {
      visitedNotes.add(title);
      let body = g.draft.content || "";
      if (depth > 1) body = expandWikilinks(body, ttlManager, currentTurn, cfg, depth - 1, visitedNotes);
      const status = ttlManager.getStatus(title, null, currentTurn);
      const ann = (status.status === 'ttl-note') ? ` (TTL: ${status.remaining} turns remaining)` : "";
      expansions.push(`\n--- Context: ${title}${ann} ---\n${body}\n--- End: ${title} ---`);
    }
  }

  return expansions.length ? (text + '\n' + expansions.join('\n')) : text;
}

/* ====================== DEBUG SHADOW ====================== */

function getOrCreateShadowDraft(config, originalDraftTitle) {
  if (!config.debugMode) return null;
  const shadowTag = `shadow-${draft.uuid}`;
  const existing = Draft.query("", "all", [shadowTag]);
  let shadow = existing[0];

  if (!shadow) {
    shadow = Draft.create();
    const today = new Date().toISOString().split('T')[0];
    shadow.content =
      `# Debug Shadow: ${originalDraftTitle}\n` +
      `Original UUID: ${draft.uuid}\n` +
      `Created: ${today}\n\n---\n\n`;
    shadow.addTag('debug-shadow');
    shadow.addTag(shadowTag);
    shadow.update();
  }
  return shadow;
}

function appendToDebugShadow(cfgSnapshot, messages, systemPrompt, ttlManager, currentTurn) {
  if (!cfgSnapshot.debugMode) return null;

  const originalTitle = draft.displayTitle || "Untitled";
  const shadow = getOrCreateShadowDraft(cfgSnapshot, originalTitle);
  if (!shadow) return null;

  const timestamp = new Date().toISOString();
  let out = `## Turn ${currentTurn} - ${timestamp}\n\n`;
  out += `### Configuration\n`;
  out += `- Model: ${cfgSnapshot.model}\n`;
  out += `- Max Tokens: ${cfgSnapshot.maxTokens}\n`;
  out += `- Expansion Depth: ${cfgSnapshot.depth}\n`;
  out += `- Use Linked Items Index: ${cfgSnapshot.useLinkedItemsIndex}\n\n`;

  out += `### TTL Status\n`;
  const hasNoteTTLs = cfgSnapshot && ttlManager.noteTTL.size > 0;
  const hasHeadingTTLs = Array.from(ttlManager.headingTTL.values()).some(m => m.size > 0);
  const hasNoteSkips = ttlManager.noteSkips.size > 0;
  const hasHeadingSkips = Array.from(ttlManager.headingSkips.values()).some(s => s.size > 0);

  if (hasNoteTTLs || hasHeadingTTLs || hasNoteSkips || hasHeadingSkips) {
    for (const [note, ex] of ttlManager.noteTTL) {
      out += `- Note TTL: ${note} â†’ ${Math.max(0, ex - currentTurn)} turns remaining\n`;
    }
    for (const [note, map] of ttlManager.headingTTL) {
      for (const [heading, ex] of map) {
        out += `- Heading TTL: ${note} / ${heading} â†’ ${Math.max(0, ex - currentTurn)} turns remaining\n`;
      }
    }
    for (const note of ttlManager.noteSkips) {
      out += `- Note skip: ${note}\n`;
    }
    for (const [note, set] of ttlManager.headingSkips) {
      for (const h of set) out += `- Heading skip: ${note} / ${h}\n`;
    }
  } else {
    out += `No TTL directives active.\n`;
  }

  out += `\n### System Prompt\n\`\`\`\n${systemPrompt || 'Default'}\n\`\`\`\n\n`;
  out += `### Messages\n\n`;
  for (const msg of messages) {
    out += `**${msg.role}:**\n\`\`\`\n${msg.content}\n\`\`\`\n\n`;
  }
  const totalChars = messages.reduce((s, m) => s + m.content.length, 0);
  const estTokens = Math.ceil(totalChars / 4);
  out += `**Tokens:** ~${estTokens} / ${cfgSnapshot.maxTokens} (${Math.round(estTokens / cfgSnapshot.maxTokens * 100)}%)\n\n---\n\n`;

  shadow.content += out;
  shadow.update();
  return shadow;
}

/* ====================== MAIN ====================== */

(function main() {
  let fullText = editor.getText();

  // Merge saved config with any inline config in the draft
  const inlineCfg = parseConfigFromDraft(fullText);
  let cfg = loadConfig();
  cfg = { ...cfg, ...inlineCfg };

  const hasInline = /-?\s*(depth|expandHistory|debugMode|maxTokens|model|useLinkedItemsIndex)::/m.test(fullText);
  const firstRun = !hasInline && !fm.exists(CONFIG_PATH);
  const forcePrompt = app.isKeyboardModifierPressed && app.isKeyboardModifierPressed(CommandOption);
  if (forcePrompt || firstRun || (cfg.promptEachRun && !hasInline)) {
    cfg = promptForConfig(cfg); if (!cfg) return;
    if (!hasInline) { injectConfigIntoDraft(cfg); fullText = editor.getText(); }
  }

  const ttlManager = new TTLManager();
  const currentTurn = countTurns(fullText);
  const userName = extractUserName(fullText);

  const { messages, systemOverride } = parseBlocks(fullText, cfg);
  if (!messages.length) { alert("No conversation detected. Start typing your message."); return; }

  // Expand wikilinks per settings
  if (messages.length > 0) {
    let lastUserIdx = -1;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === 'user') { lastUserIdx = i; break; }
    }
    if (lastUserIdx >= 0) {
      for (let i = lastUserIdx; i < messages.length; i++) {
        messages[i].content = expandWikilinks(messages[i].content, ttlManager, currentTurn, cfg, cfg.depth);
      }
    }
    if (cfg.expandHistory && lastUserIdx > 0) {
      for (let i = 0; i < lastUserIdx; i++) {
        messages[i].content = expandWikilinks(messages[i].content, ttlManager, currentTurn, cfg, cfg.depth);
      }
    }
  }

  const debugDraft = appendToDebugShadow(cfg, messages, systemOverride, ttlManager, currentTurn);

  const systemPrompt = systemOverride || "You are an AI assistant in a FLOAT block conversation. Provide helpful, concise responses.";
  const chosenModel = cfg.model || "claude-3-haiku-20240307";

  const ai = new AnthropicAI();
  const resp = ai.request({
    path: "/messages",
    method: "POST",
    data: { model: chosenModel, max_tokens: cfg.maxTokens, system: systemPrompt, messages }
  });

  if (!resp.success) {
    console.log(`ERROR ${resp.statusCode}\n${resp.responseText}`);
    alert(`API Error ${resp.statusCode}: ${resp.responseText}`);
    return;
  }

  let reply = resp.responseData?.content?.[0]?.text || "";
  reply = reply
    .replace(/^-?\s*ctx::.*$/gmi, '')
    .replace(/<!--\s*block\s+\w+\s*-->/gi, '')
    .replace(/<!--\s*endblock\s*-->/gi, '')
    .replace(/%%\s*block\s+\w+\s*%%/gi, '')
    .replace(/%%\s*endblock\s*%%/gi, '');
  reply = trimTrailing(reply) || "[No response]";

  const nextTurn = currentTurn + 1;
  let block = '';
  if (cfg.useObsidianSyntax) {
    block =
      `\n## ${nextTurn} - assistant:\n` +
      `%% block assistant %%\n` +
      `- ctx:: ${fmtCtx()}\n${reply}\n` +
      `%% endblock %%\n\n` +
      `## ${nextTurn + 1} - ${userName}:\n`;
  } else {
    block =
      `\n## ${nextTurn} - assistant:\n` +
      `<!-- block assistant -->\n` +
      `- ctx:: ${fmtCtx()}\n${reply}\n` +
      `<!-- endblock -->\n\n` +
      `## ${nextTurn + 1} - ${userName}:\n`;
  }

  const newContent = fullText + '\n' + block;
  editor.setText(newContent);
  editor.setSelectedRange(newContent.length, 0);
  editor.activate();

  if (debugDraft) console.log(`Debug shadow: ${debugDraft.uuid}`);
})();